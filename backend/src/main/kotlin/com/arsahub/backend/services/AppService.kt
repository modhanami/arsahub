package com.arsahub.backend.services

import com.arsahub.backend.SocketIOService
import com.arsahub.backend.dtos.request.*
import com.arsahub.backend.dtos.response.AchievementResponse
import com.arsahub.backend.dtos.socketio.AchievementUnlock
import com.arsahub.backend.dtos.socketio.LeaderboardUpdate
import com.arsahub.backend.dtos.socketio.PointsUpdate
import com.arsahub.backend.exceptions.ConflictException
import com.arsahub.backend.models.*
import com.arsahub.backend.repositories.*
import com.arsahub.backend.services.actionhandlers.ActionHandlerRegistry
import com.arsahub.backend.services.actionhandlers.ActionResult
import com.arsahub.backend.utils.JsonSchemaValidationResult
import com.arsahub.backend.utils.JsonUtils
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import java.time.Instant
import java.util.*


@Service
class AppService(
    private val triggerRepository: TriggerRepository,
    private val userRepository: UserRepository,
    private val appRepository: AppRepository,
    private val appUserRepository: AppUserRepository,
    private val jsonUtils: JsonUtils,
    private val achievementRepository: AchievementRepository,
    private val socketIOService: SocketIOService,
    private val ruleProgressTimeRepository: RuleProgressTimeRepository,
    private val actionRepository: ActionRepository,
    private val ruleRepository: RuleRepository,
    private val actionHandlerRegistry: ActionHandlerRegistry,
    private val leaderboardService: LeaderboardService,
    private val triggerLogRepository: TriggerLogRepository,
) {
    private val logger = KotlinLogging.logger {}

    fun createTrigger(app: App, request: TriggerCreateRequest): Trigger {
        val existingApp = app.id?.let { appRepository.findById(it).orElseThrow { Exception("App not found") } }
            ?: throw Exception("App not found")

        val autoGeneratedKey = request.key
        val validJsonSchema = request.jsonSchema?.let {
            if (jsonUtils.validateAgainstMetaSchema(it)) {
                it
            } else {
                throw Exception("Invalid JSON Schema")
            }
        }

        val trigger = Trigger(
            title = request.title,
            description = request.description,
            key = autoGeneratedKey,
            app = existingApp,
            jsonSchema = validJsonSchema?.toMutableMap()
        )

        return triggerRepository.save(trigger)
    }

    fun getTriggers(app: App): List<Trigger> {
        return triggerRepository.findAllByAppId(app.id!!)
    }

    fun getAppByUserUUID(uuid: UUID): App {
        return appRepository.findFirstByOwnerUuid(uuid) ?: throw Exception("App not found")
    }

    fun getUserByUUID(userUUID: UUID): User {
        return userRepository.findByUuid(userUUID) ?: throw Exception("User not found")
    }

    fun addUser(app: App, request: AppUserCreateRequest): AppUser {
        val appUser = appUserRepository.findByAppAndUserId(app, request.uniqueId)
        if (appUser != null) {
            throw ConflictException("App user already exists")
        }
        val newAppUser = AppUser(
            userId = request.uniqueId,
            displayName = request.displayName,
            app = app
        )
        appUserRepository.save(newAppUser)
        return newAppUser
    }

    fun listUsers(app: App): List<AppUser> {
        return appUserRepository.findAllByApp(app)
    }

    fun trigger(app: App, request: TriggerSendRequest, json: Map<String, Any>? = null) {
        val userId = request.userId

        val trigger = triggerRepository.findByKey(request.key) ?: throw Exception("Trigger not found")
        val appUser = appUserRepository.findByAppAndUserId(app, userId) ?: throw Exception("User not found")

        // save trigger log before any validation
        val triggerLog = TriggerLog(
            trigger = trigger,
            requestBody = json?.toMutableMap(),
            app = app,
            appUser = appUser
        )
        triggerLogRepository.save(triggerLog)

        // validate trigger against schema
        val triggerSchema = trigger.jsonSchema
        val triggerValidationResult = if (triggerSchema != null) {
            if (request.params.isNullOrEmpty()) {
                throw Exception("Trigger params must be provided when trigger has a schema (key: ${trigger.key})")
            }

            jsonUtils.validate(triggerSchema, request.params)
        } else {
            JsonSchemaValidationResult.valid()
        }

        logger.debug { "Trigger validation result: ${if (triggerValidationResult.isValid) "passed" else "failed"} ${triggerValidationResult.errors}" }
        if (!triggerValidationResult.isValid) {
            throw Exception("Trigger definition is not valid (${triggerValidationResult.errors})")
        }

        val matchingRules = ruleRepository.findAllByTrigger_Key(trigger.key!!)
        for (rule in matchingRules) {
            logger.debug { "Checking rule ${rule.title} (${rule.id})" }

            // check the params against the rule conditions first, if any
            if (rule.conditions != null) {
                val conditions = rule.conditions!!
                val conditionsMatch = conditions.all { condition ->
                    val paramValue = request.params?.get(condition.key)
                    val conditionValue = condition.value
                    val matches = paramValue == conditionValue // TODO: support more operators

                    if (matches) {
                        logger.debug { "Condition ${condition.key} matches" }
                    } else {
                        logger.debug { "Condition ${condition.key} does not match: $paramValue != $conditionValue" }
                    }

                    matches
                }
                if (!conditionsMatch) {
                    logger.debug { "Rule ${rule.title} (${rule.id}) conditions do not match" }
                    continue
                }
            }

            when (val actionResult = actionHandlerRegistry.handleAction(rule, appUser)) {
                is ActionResult.AchievementUpdate -> {
                    val (achievement) = actionResult
                    socketIOService.broadcastToAppRoom(
                        app,
                        AchievementUnlock(
                            userId = userId,
                            achievement = AchievementResponse.fromEntity(
                                achievement
                            )
                        )
                    )
                    socketIOService.broadcastToUserRoom(
                        userId,
                        AchievementUnlock(
                            userId = userId,
                            achievement = AchievementResponse.fromEntity(
                                achievement
                            )
                        )
                    )
                }

                is ActionResult.PointsUpdate -> {
                    val (_, newPoints, _) = actionResult
                    socketIOService.broadcastToAppRoom(
                        app,
                        PointsUpdate(
                            userId = userId,
                            points = newPoints
                        )
                    )
                    socketIOService.broadcastToAppRoom(
                        app,
                        LeaderboardUpdate(
                            leaderboard = leaderboardService.getTotalPointsLeaderboard(app)
                        )
                    )

                    socketIOService.broadcastToUserRoom(
                        userId,
                        PointsUpdate(
                            userId = userId,
                            points = newPoints
                        )
                    )
                }

                is ActionResult.Nothing -> {}
            }

        }

        // find all rules with points_reached as a trigger to activate the corresponding actions
        if (request.key != "points_reached") {
            val pointsReachedRules = ruleRepository.findAllByTrigger_Key("points_reached")
            for (rule in pointsReachedRules) {
                val value = rule.triggerParams?.get("value")?.toString()?.toInt()
                    ?: throw Exception("Value not found for rule ${rule.title} (${rule.id})")

                if ((appUser.points ?: 0) < value) {
                    continue
                }

                // check if the rule has already been activated from rule_progress_time
                if (ruleProgressTimeRepository.findByRuleAndAppUser(rule, appUser) != null) {
                    continue
                }

                println("User reached ${appUser.points} points, activating rule ${rule.title} (${rule.id})")

                trigger(
                    app,
                    TriggerSendRequest(
                        key = "points_reached",
                        params = emptyMap(),
                        userId = userId
                    )
                )

                // mark the rule as activated for the user
                val ruleProgress = RuleProgressTime(
                    rule = rule, appUser = appUser, progress = 1, completedAt = Instant.now()
                )
                ruleProgressTimeRepository.save(ruleProgress)
            }
        }

    }

    fun createRule(
        app: App, request: RuleCreateRequest
    ): Rule {
        val trigger = triggerRepository.findByKey(request.trigger.key) ?: throw Exception("Trigger not found")
        val action = actionRepository.findByKey(request.action.key) ?: throw Exception("Action not found")

        // trigger schema validation
        println("Trigger definition: ${request.trigger}")
        println("Trigger schema: ${trigger.jsonSchema}")
        val triggerSchema = trigger.jsonSchema
        val triggerValidationResult = if (triggerSchema != null) {
            if (request.trigger.params == null) {
                throw Exception("Trigger params must be provided when trigger has a schema (key: ${trigger.key})")
            }

            jsonUtils.validate(triggerSchema, request.trigger.params)
        } else {
            JsonSchemaValidationResult.valid()
        }

        println("Trigger validation result: ${triggerValidationResult.errors} (passed: ${triggerValidationResult.isValid})")
        if (!triggerValidationResult.isValid) {
            throw Exception("Trigger definition is not valid")
        }

        // action schema validation
        println("Action definition: ${request.action}")
        println("Action schema: ${action.jsonSchema}")
        val actionSchema = action.jsonSchema
        val actionValidationResult = if (actionSchema != null) {
            jsonUtils.validate(actionSchema, request.action.params)
        } else {
            JsonSchemaValidationResult.valid()
        }

        println("Action validation result: ${actionValidationResult.errors} (passed: $actionValidationResult.isValid)")
        if (!actionValidationResult.isValid) {
            throw Exception("Action definition is not valid")
        }

        // extra validation not covered by schema, like a param must reference a valid ID of an achievement to be awarded (achievementId)
        // checks like nullability, type, etc. are covered by the schema
        try {
            when (request.action.key) {
                "unlock_achievement" -> {
                    val achievementId = request.action.params["achievementId"]!!.toLong()
                    val achievement = achievementRepository.findById(achievementId)
                    if (achievement.isEmpty) {
                        throw Exception("Achievement not found")
                    }
                }
            }
        } catch (e: Exception) {
            throw Exception("Action definition is not valid", e)
        }

        val rule = Rule(
            app = app,
            title = request.name,
            description = request.description,
            trigger = trigger,
            action = action,
            actionParams = request.action.params.toMutableMap(),
            triggerParams = request.trigger.params?.toMutableMap(),
        )

        return ruleRepository.save(rule)
    }

    fun createAchievement(
        app: App,
        request: AchievementCreateRequest
    ): Achievement {
        val achievement = Achievement(
            title = request.title!!,
            description = request.description,
            app = app
        )

        achievementRepository.save(achievement)

        return achievement
    }

    fun listAchievements(app: App): List<Achievement> {
        return achievementRepository.findAllByApp(app)
    }
}

