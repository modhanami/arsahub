package com.arsahub.backend.services

import com.arsahub.backend.SocketIOService
import com.arsahub.backend.dtos.request.*
import com.arsahub.backend.dtos.response.AchievementResponse
import com.arsahub.backend.dtos.socketio.AchievementUnlock
import com.arsahub.backend.dtos.socketio.LeaderboardUpdate
import com.arsahub.backend.dtos.socketio.PointsUpdate
import com.arsahub.backend.exceptions.ConflictException
import com.arsahub.backend.models.*
import com.arsahub.backend.repositories.*
import com.arsahub.backend.services.actionhandlers.ActionHandlerRegistry
import com.arsahub.backend.services.actionhandlers.ActionResult
import com.arsahub.backend.utils.JsonSchemaValidationResult
import com.arsahub.backend.utils.JsonUtils
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import java.time.Instant
import java.util.*


@Service
class AppService(
    private val triggerRepository: TriggerRepository,
    private val userRepository: UserRepository,
    private val appRepository: AppRepository,
    private val appUserRepository: AppUserRepository,
    private val jsonUtils: JsonUtils,
    private val achievementRepository: AchievementRepository,
    private val socketIOService: SocketIOService,
    private val ruleProgressTimeRepository: RuleProgressTimeRepository,
    private val ruleRepository: RuleRepository,
    private val actionHandlerRegistry: ActionHandlerRegistry,
    private val leaderboardService: LeaderboardService,
    private val triggerLogRepository: TriggerLogRepository,
) {
    private val logger = KotlinLogging.logger {}

    fun createTrigger(app: App, request: TriggerCreateRequest): Trigger {
        val existingApp = app.id?.let { appRepository.findById(it).orElseThrow { Exception("App not found") } }
            ?: throw Exception("App not found")

        val autoGeneratedKey = request.key
        val validJsonSchema = request.jsonSchema?.let {
            if (jsonUtils.validateAgainstMetaSchema(it)) {
                it
            } else {
                throw Exception("Invalid JSON Schema")
            }
        }

        val trigger = Trigger(
            title = request.title,
            description = request.description,
            key = autoGeneratedKey,
            app = existingApp,
            jsonSchema = validJsonSchema?.toMutableMap()
        )

        return triggerRepository.save(trigger)
    }

    fun getTriggers(app: App): List<Trigger> {
        return triggerRepository.findAllByAppId(app.id!!)
    }

    fun getAppByUserUUID(uuid: UUID): App {
        return appRepository.findFirstByOwnerUuid(uuid) ?: throw Exception("App not found")
    }

    fun getUserByUUID(userUUID: UUID): User {
        return userRepository.findByUuid(userUUID) ?: throw Exception("User not found")
    }

    fun addUser(app: App, request: AppUserCreateRequest): AppUser {
        val appUser = appUserRepository.findByAppAndUserId(app, request.uniqueId)
        if (appUser != null) {
            throw ConflictException("App user already exists")
        }
        val newAppUser = AppUser(
            userId = request.uniqueId,
            displayName = request.displayName,
            app = app
        )
        appUserRepository.save(newAppUser)
        return newAppUser
    }

    fun listUsers(app: App): List<AppUser> {
        return appUserRepository.findAllByApp(app)
    }

    fun trigger(app: App, request: TriggerSendRequest, json: Map<String, Any>? = null) {
        val userId = request.userId

        val trigger = triggerRepository.findByKey(request.key) ?: throw Exception("Trigger not found")
        val appUser = appUserRepository.findByAppAndUserId(app, userId) ?: throw Exception("User not found")

        // save trigger log before any validation
        val triggerLog = TriggerLog(
            trigger = trigger,
            requestBody = json?.toMutableMap(),
            app = app,
            appUser = appUser
        )
        triggerLogRepository.save(triggerLog)

        // validate trigger against schema
        val triggerSchema = trigger.jsonSchema
        val triggerValidationResult = if (triggerSchema != null) {
            if (request.params.isNullOrEmpty()) {
                throw Exception("Trigger params must be provided when trigger has a schema (key: ${trigger.key})")
            }

            jsonUtils.validate(triggerSchema, request.params)
        } else {
            JsonSchemaValidationResult.valid()
        }

        logger.debug { "Trigger validation result: ${if (triggerValidationResult.isValid) "passed" else "failed"} ${triggerValidationResult.errors}" }
        if (!triggerValidationResult.isValid) {
            throw Exception("Trigger definition is not valid (${triggerValidationResult.errors})")
        }

        val matchingRules = ruleRepository.findAllByTrigger_Key(trigger.key!!)
        for (rule in matchingRules) {
            logger.debug { "Checking rule ${rule.title} (${rule.id})" }

            // check the params against the rule conditions first, if any
            if (rule.conditions != null) {
                val conditions = rule.conditions!!
                val conditionsMatch = conditions.all { condition ->
                    val paramValue = request.params?.get(condition.key)
                    val conditionValue = condition.value
                    val matches = paramValue == conditionValue // TODO: support more operators

                    if (matches) {
                        logger.debug { "Condition ${condition.key} matches" }
                    } else {
                        logger.debug { "Condition ${condition.key} does not match: $paramValue != $conditionValue" }
                    }

                    matches
                }
                if (!conditionsMatch) {
                    logger.debug { "Rule ${rule.title} (${rule.id}) conditions do not match" }
                    continue
                }
            }

            when (val actionResult = actionHandlerRegistry.handleAction(rule, appUser)) {
                is ActionResult.AchievementUpdate -> {
                    val (achievement) = actionResult
                    socketIOService.broadcastToAppRoom(
                        app,
                        AchievementUnlock(
                            userId = userId,
                            achievement = AchievementResponse.fromEntity(
                                achievement
                            )
                        )
                    )
                    socketIOService.broadcastToUserRoom(
                        userId,
                        AchievementUnlock(
                            userId = userId,
                            achievement = AchievementResponse.fromEntity(
                                achievement
                            )
                        )
                    )
                }

                is ActionResult.PointsUpdate -> {
                    val (_, newPoints, _) = actionResult
                    socketIOService.broadcastToAppRoom(
                        app,
                        PointsUpdate(
                            userId = userId,
                            points = newPoints
                        )
                    )
                    socketIOService.broadcastToAppRoom(
                        app,
                        LeaderboardUpdate(
                            leaderboard = leaderboardService.getTotalPointsLeaderboard(app)
                        )
                    )

                    socketIOService.broadcastToUserRoom(
                        userId,
                        PointsUpdate(
                            userId = userId,
                            points = newPoints
                        )
                    )
                }

                is ActionResult.Nothing -> {}
            }

        }

    }

    fun createRule(
        app: App, request: RuleCreateRequest
    ): Rule {
        val trigger = triggerRepository.findByKey(request.trigger.key) ?: throw Exception("Trigger not found")

        // trigger schema validation
        println("Trigger definition: ${request.trigger}")
        println("Trigger schema: ${trigger.jsonSchema}")
        val triggerSchema = trigger.jsonSchema
        val triggerValidationResult = if (triggerSchema != null) {
            if (request.trigger.params == null) {
                throw Exception("Trigger params must be provided when trigger has a schema (key: ${trigger.key})")
            }

            jsonUtils.validate(triggerSchema, request.trigger.params)
        } else {
            JsonSchemaValidationResult.valid()
        }

        println("Trigger validation result: ${triggerValidationResult.errors} (passed: ${triggerValidationResult.isValid})")
        if (!triggerValidationResult.isValid) {
            throw Exception("Trigger definition is not valid")
        }

        val rule = Rule(
            app = app,
            title = request.name,
            description = request.description,
            trigger = trigger,
            triggerParams = request.trigger.params?.toMutableMap(),
        )

        val actionDefinition: ActionDefinition = request.action
        rule.action = actionDefinition.key
        when (actionDefinition) {
            is AddPointsAction -> {
                require(actionDefinition.points > 0) { "Points must be greater than 0" }
                rule.actionPoints = actionDefinition.points
            }

            is UnlockAchievementAction -> {
                val achievement = achievementRepository.findById(actionDefinition.achievementId)
                if (achievement.isEmpty) {
                    throw IllegalArgumentException("Achievement not found")
                }
                rule.actionAchievement = achievement.get()
            }
        }

        return ruleRepository.save(rule)
    }

    fun createAchievement(
        app: App,
        request: AchievementCreateRequest
    ): Achievement {
        val achievement = Achievement(
            title = request.title!!,
            description = request.description,
            app = app
        )

        achievementRepository.save(achievement)

        return achievement
    }

    fun listAchievements(app: App): List<Achievement> {
        return achievementRepository.findAllByApp(app)
    }
}

